const canvas = document.getElementById("c")
const ctx = canvas.getContext("2d")
let width = window.innerWidth
let height = window.innerHeight
let ballCount = 20 //amount of balls to spawn at the beginning
let gravity = 3 //vy applied per frame
let maxSpeed = 100 //maximum velocity of a ball
let friction = 1 //multiplies both vx and vy by this to simulate air friction
function updateCanvas() {
    width = window.innerWidth
    height = window.innerHeight
    canvas.width = width
    canvas.height = height
} //changes the canvas size to fit to width and height and change the width and height to fit the window size
function colorGen() {
    let c
    let mainC = Math.round(Math.random()*2)
    if (mainC == 0) {
        c = "RGB("+255+","+Math.round(Math.random()*255)+","+Math.round(Math.random()*255)+")"
    } else if (mainC == 1) {
        c = "RGB("+Math.round(Math.random()*255)+","+255+","+Math.round(Math.random()*255)+")"
    } else if (mainC == 2) {
        c = "RGB("+Math.round(Math.random()*255)+","+Math.round(Math.random()*255)+","+255+")"
    }
    return c
} //chooses one main color oiut of R G or B at random and takes a shade of it
let balls = [] //Array for ball instances
function ballSpawn() {
    if (balls.length < ballCount) {
        balls.push(
            {
                r: 10, //radius
                x: 10 + Math.random()*(width-(10)), //X posistion
                y: 10 * 1.5, //Y posistion
                vx: (Math.random()*60)-30, //X velocity
                vy: 0, //Y velocity
                c: colorGen(), //color
                e: (Math.random()*0.5)+0.4 //elasticity
            }
        )
        console.log(balls[0])
    }
    
}// spawns a single ball with a random x posistion, random initial velocities, and color generated by colorGen()
function collision(p1x, p1y, r1, p2x, p2y, r2) {
    var a;
    var x;
    var y;
  
    a = r1 + r2;
    x = p1x - p2x;
    y = p1y - p2y;
  
    if (a > Math.sqrt((x * x) + (y * y))) {
      return true;
    } else {
      return false;
    }
}
function ballPhysics() {
    for (let i = 0; i< balls.length; i++) {
        if (balls[i].vy + gravity <= maxSpeed && balls[i].y < height-(balls[i].r*1.5)) {
            balls[i].vy += gravity
        }
        if (balls[i].x + balls[i].r + balls[i].vx > width || balls[i].x + -balls[i].r + balls[i].vx < 0 ) {
            balls[i].vx *= -balls[i].e
        }
        if (balls[i].y + balls[i].r + balls[i].vy > height || balls[i].y + -balls[i].r + balls[i].vy < 0) {
            balls[i].vy *= -balls[i].e
        }
        for (let j = i + 1; j < balls.length; j++) {
            if (collision(balls[i].x, balls[i].y, balls[i].r, balls[j].x, balls[j].y, balls[j].r)) {
                // Calculate normal vector
                let nx = balls[j].x - balls[i].x;
                let ny = balls[j].y - balls[i].y;
                let distance = Math.sqrt(nx * nx + ny * ny);
                nx /= distance;
                ny /= distance;

                // Resolve velocities along the normal
                let p = 2 * (balls[i].vx * nx + balls[i].vy * ny - balls[j].vx * nx - balls[j].vy * ny) / (balls[i].r + balls[j].r);

                // Calculate new velocities
                balls[i].x = balls[i].x + (nx*10)
                balls[i].y = balls[i].y + (nx*10)

                balls[j].x = balls[j].x + (nx*10)
                balls[j].y = balls[j].y + (nx*10)

                balls[i].vx -= p * balls[i].r * nx;
                balls[i].vy -= p * balls[i].r * ny;
                balls[j].vx += p * balls[j].r * nx;
                balls[j].vy += p * balls[j].r * ny;
            }
        }
        balls[i].x += balls[i].vx
        balls[i].y += balls[i].vy
        if (balls[i].x > width) {
            balls[i].x = width - balls[i].r
        }
        if (balls[i].y > height) {
            balls[i].y = height - balls[i].r
        }
        if (balls[i].x < 0) {
            balls[i].x = balls[i].r
        }
        if (balls[i].y < 0) {
            balls[i].y = balls[i].r
        }
        if (balls[i].vy > maxSpeed) {
            balls[i].vy = maxSpeed
        }
        if (balls[i].vy < -maxSpeed) {
            balls[i].vy = -maxSpeed
        }
        if (balls[i].vx > maxSpeed) {
            balls[i].vx = maxSpeed
        }
        if (balls[i].vx < -maxSpeed) {
            balls[i].vx = -maxSpeed
        }
        balls[i].vx *= friction
        balls[i].vy *= friction
        if (Math.abs(balls[i].vx <= 2)) {
            balls[i].vx = 0
        }
        if (Math.abs(balls[i].vy <= 2)) {
            balls[i].vy = 0
        }
    }
}// applies gravity, handles collisions, handles friction, ensures balls dont leave the bounds and that a ball's speed doesn't exceed max speed
function draw() {
    ctx.clearRect(0,0,width,height)
    ctx.fillStyle = "black"
    ctx.fillRect(0,0,width,height)
    for (let i = 0; i< balls.length; i++) {
        ctx.beginPath();
        ctx.arc(balls[i].x, balls[i].y, balls[i].r, 0, 2 * Math.PI);
        ctx.fillStyle = balls[i].c
        ctx.fill()   
    }
}//draws the bg as plain black then loops through and draws all balls
function loop() {
    updateCanvas()
    ballSpawn()
    ballPhysics()
    draw()
}//handles the function calls

function start() {
    document.body.style.overflow = 'hidden';
    
    setInterval(loop,20)
}//removes the scroll bars and sets loop() to run every 20ms ensuring 50fps
start()//initializes the program

